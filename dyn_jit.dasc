#include "jitter.h"
#include "dasm_driver.h"
#include "dynasm/dasm_x86.h"
#include <stdio.h>

| .arch x64
|.actionlist actions
|.macro callp, addr
|  mov64  rax, (uintptr_t)addr
|  call   rax
|.endmacro
|.include jit_macros.h
#define Dst &state
dasm_State *state;
processor_state proc_state;
uintptr_t proc_ptr = (uintptr_t)&proc_state;
extern uint16_t* main_memory;

int jit_instruction(uint16_t* inst);
void finish(){
    for(int i=0;i<8;i++){
        printf("r%d: %04x\n",i,proc_state.regs[i]);
    }
    exit(0);
}
jit_function branch_to(uint16_t addr){
    initjit(&state,actions);
    printf("Compiling a branch to %04x\n",addr);
    uint16_t* instructions = main_memory + (addr/2);
    uintptr_t mem_ptr = (uintptr_t) main_memory;
    |push rbp
    |mov rbp,rsp
    |push r12
    |push r11

    |mov64 r12,proc_ptr
    |mov64 r11, mem_ptr

    while(*instructions <0xff00){
        instructions += jit_instruction(instructions);
    }

    |pop r11
    |pop r12
    |callp finish
    |pop rbp


    jit_function func = jitcode(&state);
    return func;


}
void branch_test(uintptr_t ptr){
    printf("Supposed to branch here: %p\n",ptr);
}
int jit_instruction(uint16_t* inst){
    uint8_t opcode = *inst >>8;
    uint8_t reg_sel = *inst & 0xff;
    uint8_t rD = reg_sel & 0x7;
    uint8_t rS = (reg_sel>>3) &0x7;
    uint8_t conditon = (reg_sel>>3) & 0xF;
    uint16_t imm = *(inst+1);
    switch(opcode){
        case ADD:
            |inst_rr add
            break;
        case SUB:
            |inst_rr sub
            break;
        case PUSH:
            |mov ax, [r12+(rD*2)]
            |movsx rdx, word [r12+(14)]
            |sub rdx,2
            |mov [r11+rdx], ax
            |mov [r12+14], dx
            break;
        case POP:
            |movsx rdx, word [r12+14]
            |mov ax,[r11+rdx]
            |mov [r12+(rD*2)],ax
            |add rdx,2
            |mov [r12+14],dx
            break;
        case MOVB_R0:
        case MOVB_R1:
        case MOVB_R2:
        case MOVB_R3:
        case MOVB_R4:
        case MOVB_R5:
        case MOVB_R6:
        case MOVB_R7:
            |mov word [r12+(opcode-MOVB_R0)], reg_sel
            break;
        case MOV:
            |inst_rr mov
            break;
        case CMP:
            |mov ax, [r12+(rD*2)]
            |mov dx, [r12+(rS*2)]
            |cmp ax,dx
            break;


        case ADDI:
            | inst_ri add
            break;
        case SUBI:
            |inst_ri sub
            break;
        case PUSHI:
            |movsx rdx, word [r12+14]
            |sub rdx,2
            |mov word [r11+rdx], imm
            |mov [r12+14], dx
            break;
        case MOVI:
            |inst_ri mov
            break;
        case CMPI:
            |mov ax, [r12+(rD*2)]
            |cmp ax, imm
            break;
        case JMPI:
            switch(conditon){
                case AL:
                    |mov rdi, imm
                    |callp branch_to
                    |jmp rax
                    break;
                case NE:
                    |je >1
                    |mov rdi, imm
                    |callp branch_to
                    |jmp rax
                    |1:
                    break;

            }
            break;


    }

    return (opcode & 0x80) ? 2 : 1;
}
