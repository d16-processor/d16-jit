#include "jitter.h"
#include "dasm_driver.h"
#include "dasm_x86.h"
#include <stdio.h>
#include <glib.h>
| .arch x64
|.globals glob_
|.actionlist actions
|.macro callp, addr
|  mov64  rax, (uintptr_t)addr
|  call   rax
|.endmacro
|.include jit_macros.h
#define Dst &state
dasm_State *state;
int pclabel =0;
GHashTable* trace_cache;
processor_state proc_state;
uintptr_t proc_ptr = (uintptr_t)&proc_state;
extern uint16_t* main_memory;

int jit_instruction(uint16_t* inst);
void finish(){
    for(int i=0;i<8;i++){
        printf("r%d: %04x\n",i,proc_state.regs[i]);
    }
    exit(0);
}
void init_jit(){
    trace_cache = g_hash_table_new(g_direct_hash,g_direct_equal);
}
jit_function branch_to(uint16_t addr){
    //printf("branch to: %04x\n",addr);
    if(g_hash_table_contains(trace_cache,GINT_TO_POINTER(addr))){
        //printf("Taking cached branch\n");
        return g_hash_table_lookup(trace_cache,GINT_TO_POINTER(addr));
    }
    initjit(&state,actions);
    //printf("Compiling a branch to %04x\n",addr);
    uint16_t* instructions = main_memory + (addr/2);
    uintptr_t mem_ptr = (uintptr_t) main_memory;
    |push rbp
    |mov rbp,rsp
    |push r12
    |push r11
    //|push rbx

    |mov64 r12,proc_ptr
    |mov64 r11, mem_ptr
	int bytes = 0;
    while((bytes = jit_instruction(instructions))!= -1){
        instructions += bytes;
    }
    //|pop rbx
    |pop r11
    |pop r12
    |mov  rsp, rbp
    |callp finish
    |pop rbp


    jit_function func = jitcode(&state);
    g_hash_table_insert(trace_cache,GINT_TO_POINTER(addr),func);

    return func;


}
void branch_test(uintptr_t ptr){
    printf("Supposed to branch here: %lu\n",ptr);
}
int jit_instruction(uint16_t* inst){
    uint8_t opcode = *inst >>8;
    uint8_t reg_sel = *inst & 0xff;
    uint8_t rD = reg_sel & 0x7;
    uint8_t rS = (reg_sel>>3) &0x7;
    uint8_t conditon = (reg_sel>>3) & 0xF;
    uint16_t imm = *(inst+1);
    switch(opcode){
        case ADD:
            |inst_rr add
            break;
        case SUB:
            |inst_rr sub
            break;
        case PUSH:
            |mov ax, [r12+(rD*2)]
            |movsx rdx, word [r12+(14)]
            |sub rdx,2
            |mov [r11+rdx], ax
            |mov [r12+14], dx
            break;
        case POP:
            |movsx rdx, word [r12+14]
            |mov ax,[r11+rdx]
            |mov [r12+(rD*2)],ax
            |add rdx,2
            |mov [r12+14],dx
            break;
        case MOVB_R0:
        case MOVB_R1:
        case MOVB_R2:
        case MOVB_R3:
        case MOVB_R4:
        case MOVB_R5:
        case MOVB_R6:
        case MOVB_R7:
            |mov word [r12+((opcode-MOVB_R0)*2)], reg_sel
            break;
        case MOV:
            |inst_rr mov
            break;
		case AND:
			|inst_rr and
			break;
		case OR:
			|inst_rr or
			break;
		case XOR:
			|inst_rr xor
			break;
		case NOT:
			|not word [r12+(rD*2)]
			break;
		case NEG:
			|neg word [r12+(rD*2)]
			break;
        case CMP:
            |mov ax, [r12+(rD*2)]
            |mov dx, [r12+(rS*2)]
            |cmp ax,dx
            break;


        case ADDI:
            | inst_ri add
            break;
        case SUBI:
            |inst_ri sub
            break;
        case PUSHI:
            |movsx rdx, word [r12+14]
            |sub rdx,2
            |mov word [r11+rdx], imm
            |mov [r12+14], dx
            break;
        case MOVI:
            |inst_ri mov
            break;
		case ANDI:
			|inst_ri and
			break;
		case ORI:
			|inst_ri or
			break;
		case XORI:
			|inst_ri xor
			break;
        case CMPI:
            |mov ax, [r12+(rD*2)]
            |cmp ax, imm
            break;
        case JMPI:
            switch(conditon){
                case AL:
                    |mov rdi, imm
                    |callp branch_to
                    |mov rsp,rbp
                    |pop rbp
                    |jmp rax
                    break;
				case EQ:
					|cond_jmp jne
					break;
                case NE:
                    |cond_jmp je
					break;
				case OS:
					|cond_jmp jno
					break;
				case OC:
					|cond_jmp jo
					break;
				case HI:
					|cond_jmp jbe
					break;
				case LS:
					|cond_jmp ja
					break;
				case P:
					|cond_jmp js
					break;
				case N:
					|cond_jmp jns
					break;
                case CS:
                    |cond_jmp jnc
					break;
                case CC:
                    |cond_jmp jc
					break;
				case GE:
					|cond_jmp jl
					break;
				case G:
					|cond_jmp jle
					break;
				case LE:
					|cond_jmp jg
					break;
				case L:
					|cond_jmp jge
					break;
            }
			return -1;
            break;
		case 0xFF: return -1;
        default:

            break;

    }

    return (opcode & 0x80) ? 2 : 1;
}
